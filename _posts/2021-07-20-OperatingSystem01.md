# 1. 운영체제란?
컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 모든 SW와 HW를 연결하는 SW계층 
￼
# 2. 운영체제의 목적
## 1. 편리하게 사용할 수 있는 환경을 제공
   - 현대시대의 컴퓨터에서는 하나의 프로그램이 동작하는 것이 아닌 여러개의 프로그램이 동작함.
   - 각각의 프로그램의 입장에서 혼자만 컴퓨터를 사용하는 것처럼 인식하게 Illusion을 제공 (내부적인 처리는 운영체제가 제공)
## 2. 자원을 효율적으로 관리
   - 자원(CPU, Memory, I/O Device 등)의 효율적 관리
   - 운영체제가 자원에 대한 Sharing 제공 (실행 중인 프로그램들에게 CPU 번갈아 할당 / 메모리[ CPU 작업공간 ] 공간 할당)
   - 한정된 자원을 관리하여 최대한의 효율성(성능) & 형평성 제공
# 3. 컴퓨터 시스템의 내부 구조
## 1. 운영체제 기능￼
* 부팅 후에 운영체제가 메모리에 상주
* 운영체제 기능
   - CPU 스케줄링 : 어떤 프로그램에게 CPU 사용권을 얼마나 줄까 ?
   - 메모리 관리 : 한정된 메모리를 어떻게 쪼개어 쓰지?
   - 디스크 스케줄링 : 디스크에 들어온 요청을 어떤 순서로 처리할까?
   - 인터럽트, 캐싱 : 빠른 CPU와 느린 I/O장치간 속도 차이를 어떻게 극복하지?
# 4. 프로세스의 상태
￼CPU 큐를 만들어서 CPU를 사용할 프로그램을 줄세움.
- 예) 디스크를  사용해야한다 -> 디스크 입출력 큐로 보내지고 다음 CPU 큐에 있는 프로그램이 옴.
프로그램 : Interactive Application, Scientific Application 

# 5. CPU 스케줄링
  - 여러 프로그램들이 CPU를 사용하겠다고 기다리고 있는 상
  - FCFS(First Come First Served)
      - 먼저 들어온 프로세스에게 우선권을 줌
      - ex1) p1(24) > p2(3) > p3(3) 순서로 들어옴(동시에라고 가정)
      - Waiting Time (p1 : 0, p2 : 24, p3 : 27)
      - 평균 Waiting Time 17 
      - ex2) p2(3) > p3(3) > p1(24) 순서로 들어옴(동시에라고 가정)
      - Waiting Time (p1 : 6, p2 : 0, p3 : 3)
      - 평균 Waiting Time 3 
      - 먼저 들어온 프로세스가 사용하는 시간에 따라서 평균 대기 시간의 차이가 분명함.
  - SJF (Shortest Job First)
      - CPU 사용시간이 가장 짧은 프로세스 먼저 스케줄
      - Minimum Average Waitng Time 보장
      - ex1) p1(24) > p2(3) > p3(3) 순서로 들어옴(동시에라고 가정)
      - p2(3) > p3(3) > p1(24)로 실행
      - 효율성은 좋지만 형평성의 문제가 생김 (Starvation, 기아현상 발생이 가능하다.) -> CPU 사용시간이 긴 프로세스가 계속해서 밀려 CPU를 사용 못할 수 있음.
  - Round Robin(RR)
      - 프로세스가 일정한 CPU 할당 시간을 가지며 할당 시간이 끝날경우 "인터럽트" 발생 후 CPU 큐에 다시 들어감.
      - 하드웨어적인 기능을 통해서 인터럽트를 발생
# 6. 메모리 관리
  - 메모리는 휘발성 매체기 때문에 비어있다가 실행 시 운영체제가 올라감.
  - 디스크에 있는 실행 파일을 시작시 메모리에 올라감
      - 1. 디스크[파일시스템] : 실행파일 실행
      - 2. 가상메모리 (프로세스)
      - 3. 메모리에 올라감 (한정된 메모리를 사용하기 위해 프로세스의 필요 부분(일부)만 올려서 사용)
      - 4. 디스크[스왑영역]에 메모리의 연장 공간으로 사용이 종료된 프로세스, 사용 시 필요한 프로세스를 가지고있음.
  - LRU vs. LFU
      - LRU : 가장 오래 전에 참조 페이지(프로세스를 쪼갠 단위) 삭제
      - LFU : 참조 횟수가 가장 적은 페이지를 삭제
      - 1, 1, 1, 1, 2, ,2 ,3, 3, 2, 4, 5, (현재)...  로 들어온다는 가정
      - 메모리는 4칸 [  ] [  ] [  ] [  ]
      -  [1] [2] [3] [4]   <- 5번이 들어갈 순서가 되었을 때
         -  LRU : 1 Page 삭제 => [2] [3] [4] [5]
         -  LFU : 4 Page 삭제 => [1] [2] [3] [5]
# 7. 디스크 스케줄링
  - 원판이 회전하는 매체(헤드가 움직이며 작동하고, 헤드가 트랙을 이동하며 데이터를 읽음)
  - 디스크를 효율적으로 관리하기 위해서는 헤드의 이동을 최대한 줄여서 스케줄링 해야함.
  - 디스크 접근 시간의 구성(3가지 구성요소)
      1. 탐색시간(Seek Time) (가장 많은 시간을 차지)
          - 디스크 헤드가 움직이는 시간
      2. 회전지연(Rotational Latency)
          - 헤드가 원하는 섹터에 도달하기까지 걸리는 시간
      3. 전송시간(Transfer Time)
          - 실제 데이터 전송 시간
  - FCFS : 헤드의 이동이 상당히 길어짐
  - SSTF : Shortest Seek Time First 
      - 탐색시간(Seektime이 가장 짧은, 현재 위치에서 가장 가까운)이 짧은 위치로 이동
      - Starvation의 문제가 존재
      - 효율성은 있으나 형평성이 부족
  - SCAN : 대표적인 방법
      - 큐의 요청이 중요하지 않고 헤드가 한쪽 끝에서 다른쪽 끝까지 이동하며 가는 길목에 있는 요청을 처리
      - 시작 -> 끝 -> 시작 -> 끝 ... 이동하면서 읽음.
# 8. 저장장치 계층 구조와 캐싱(Caching)
  - 계층 구조 중 가장 상단에 위치 : CPU
  - Register에 있는 값을 통해 계산
  - 레지스터와 메인 메모리의 속도 조절을 위해 캐시메모리가 존재
  - 위로 올라갈수록 빠르고 비쌈.
  - 아래로 갈수록 싸고 용량이 큼
  - 휘발성 vs 비휘발성
      - Primary : 휘발성
      - Secondary : 비휘발성
  - Primary vs. Secondary
      - Primary : CPU가 직접 실행 가능
      - Secondary : I/O Device라고 보면됨.(CPU가 직접 실행 불가)
# 9. 플래시 메모리
  - 반도체 장치 (하드디스크는 마그네틱임)
  - NAND형과 NOR 형이 있는데 대부분의 PC에서는 NAND형을 사용
  - 전력소모가 적음
  - 물리적 충격에 강함(HDD보다)
  - 크기가 작으며 가벼움
